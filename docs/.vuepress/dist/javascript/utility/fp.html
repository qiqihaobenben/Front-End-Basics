<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>函数式编程 | Front-End-Basics</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="陈方旭的个人文档">
    
    <link rel="preload" href="/assets/css/0.styles.e4d8b86b.css" as="style"><link rel="preload" href="/assets/js/app.3f9992d7.js" as="script"><link rel="preload" href="/assets/js/2.b9bee1c3.js" as="script"><link rel="preload" href="/assets/js/147.486b066a.js" as="script"><link rel="prefetch" href="/assets/js/10.6cc694f1.js"><link rel="prefetch" href="/assets/js/100.10bfa34e.js"><link rel="prefetch" href="/assets/js/101.4844cb35.js"><link rel="prefetch" href="/assets/js/102.d83128eb.js"><link rel="prefetch" href="/assets/js/103.e61c9f66.js"><link rel="prefetch" href="/assets/js/104.740c8655.js"><link rel="prefetch" href="/assets/js/105.f14e864b.js"><link rel="prefetch" href="/assets/js/106.8662809f.js"><link rel="prefetch" href="/assets/js/107.f7579b24.js"><link rel="prefetch" href="/assets/js/108.0e56c14e.js"><link rel="prefetch" href="/assets/js/109.ab79fa60.js"><link rel="prefetch" href="/assets/js/11.b54f14af.js"><link rel="prefetch" href="/assets/js/110.db1fc531.js"><link rel="prefetch" href="/assets/js/111.ab4d95cc.js"><link rel="prefetch" href="/assets/js/112.b992d808.js"><link rel="prefetch" href="/assets/js/113.bad6e6e1.js"><link rel="prefetch" href="/assets/js/114.ddd179f4.js"><link rel="prefetch" href="/assets/js/115.77900b43.js"><link rel="prefetch" href="/assets/js/116.dfefeec1.js"><link rel="prefetch" href="/assets/js/117.736dcd84.js"><link rel="prefetch" href="/assets/js/118.b8546f58.js"><link rel="prefetch" href="/assets/js/119.0b6dff37.js"><link rel="prefetch" href="/assets/js/12.6f57be8b.js"><link rel="prefetch" href="/assets/js/120.48f24f57.js"><link rel="prefetch" href="/assets/js/121.b5fabcf8.js"><link rel="prefetch" href="/assets/js/122.99647f69.js"><link rel="prefetch" href="/assets/js/123.998cdb0d.js"><link rel="prefetch" href="/assets/js/124.e8f39814.js"><link rel="prefetch" href="/assets/js/125.7c94e38d.js"><link rel="prefetch" href="/assets/js/126.39224229.js"><link rel="prefetch" href="/assets/js/127.3c2d3c58.js"><link rel="prefetch" href="/assets/js/128.e29bdc50.js"><link rel="prefetch" href="/assets/js/129.fbfdd24c.js"><link rel="prefetch" href="/assets/js/13.7fd1998e.js"><link rel="prefetch" href="/assets/js/130.1e94b808.js"><link rel="prefetch" href="/assets/js/131.e42eb23f.js"><link rel="prefetch" href="/assets/js/132.00dfecae.js"><link rel="prefetch" href="/assets/js/133.e98b65c9.js"><link rel="prefetch" href="/assets/js/134.1a201773.js"><link rel="prefetch" href="/assets/js/135.db25f217.js"><link rel="prefetch" href="/assets/js/136.58826ef8.js"><link rel="prefetch" href="/assets/js/137.40fc25e8.js"><link rel="prefetch" href="/assets/js/138.4979226a.js"><link rel="prefetch" href="/assets/js/139.d764aeb5.js"><link rel="prefetch" href="/assets/js/14.764984d3.js"><link rel="prefetch" href="/assets/js/140.48c2d35a.js"><link rel="prefetch" href="/assets/js/141.6761b958.js"><link rel="prefetch" href="/assets/js/142.c25f1e83.js"><link rel="prefetch" href="/assets/js/143.fb560b6f.js"><link rel="prefetch" href="/assets/js/144.a26ef32b.js"><link rel="prefetch" href="/assets/js/145.04d7760b.js"><link rel="prefetch" href="/assets/js/146.802d0534.js"><link rel="prefetch" href="/assets/js/148.1fecebc1.js"><link rel="prefetch" href="/assets/js/149.47df69dd.js"><link rel="prefetch" href="/assets/js/15.f8857e9e.js"><link rel="prefetch" href="/assets/js/150.613b79ff.js"><link rel="prefetch" href="/assets/js/151.82e2c645.js"><link rel="prefetch" href="/assets/js/152.c69a5c36.js"><link rel="prefetch" href="/assets/js/153.f1377716.js"><link rel="prefetch" href="/assets/js/154.c7f0b739.js"><link rel="prefetch" href="/assets/js/155.49a2484f.js"><link rel="prefetch" href="/assets/js/156.14d26974.js"><link rel="prefetch" href="/assets/js/157.0e8db98c.js"><link rel="prefetch" href="/assets/js/158.efa5a4a1.js"><link rel="prefetch" href="/assets/js/159.95403439.js"><link rel="prefetch" href="/assets/js/16.c7522f40.js"><link rel="prefetch" href="/assets/js/160.40fb0ddd.js"><link rel="prefetch" href="/assets/js/161.c3646264.js"><link rel="prefetch" href="/assets/js/162.881a733c.js"><link rel="prefetch" href="/assets/js/163.7d4e9a4e.js"><link rel="prefetch" href="/assets/js/164.45abece5.js"><link rel="prefetch" href="/assets/js/165.f70f28fe.js"><link rel="prefetch" href="/assets/js/166.b0b44469.js"><link rel="prefetch" href="/assets/js/167.06c39265.js"><link rel="prefetch" href="/assets/js/168.9ca3dccc.js"><link rel="prefetch" href="/assets/js/169.9e5ad2b0.js"><link rel="prefetch" href="/assets/js/17.dc6c8e1a.js"><link rel="prefetch" href="/assets/js/170.ccd4c51a.js"><link rel="prefetch" href="/assets/js/171.31b14d61.js"><link rel="prefetch" href="/assets/js/172.ac974f9b.js"><link rel="prefetch" href="/assets/js/173.fac9213f.js"><link rel="prefetch" href="/assets/js/174.a9960970.js"><link rel="prefetch" href="/assets/js/175.0e978c09.js"><link rel="prefetch" href="/assets/js/176.9499a3ea.js"><link rel="prefetch" href="/assets/js/177.ca0cedfa.js"><link rel="prefetch" href="/assets/js/178.be4e7b52.js"><link rel="prefetch" href="/assets/js/18.c860de67.js"><link rel="prefetch" href="/assets/js/19.e6506ad7.js"><link rel="prefetch" href="/assets/js/20.c3217da1.js"><link rel="prefetch" href="/assets/js/21.30166fa1.js"><link rel="prefetch" href="/assets/js/22.7bdb7807.js"><link rel="prefetch" href="/assets/js/23.89cef278.js"><link rel="prefetch" href="/assets/js/24.fa17a67d.js"><link rel="prefetch" href="/assets/js/25.7ef9f03d.js"><link rel="prefetch" href="/assets/js/26.97c7342b.js"><link rel="prefetch" href="/assets/js/27.3135678c.js"><link rel="prefetch" href="/assets/js/28.21ed1793.js"><link rel="prefetch" href="/assets/js/29.c9d72584.js"><link rel="prefetch" href="/assets/js/3.8f8d9ecb.js"><link rel="prefetch" href="/assets/js/30.969b556a.js"><link rel="prefetch" href="/assets/js/31.fb61907e.js"><link rel="prefetch" href="/assets/js/32.e2aca1ba.js"><link rel="prefetch" href="/assets/js/33.314f0e02.js"><link rel="prefetch" href="/assets/js/34.822f921f.js"><link rel="prefetch" href="/assets/js/35.eb7bc312.js"><link rel="prefetch" href="/assets/js/36.fb3d3b51.js"><link rel="prefetch" href="/assets/js/37.a22e300f.js"><link rel="prefetch" href="/assets/js/38.d5f9fe85.js"><link rel="prefetch" href="/assets/js/39.25b05af6.js"><link rel="prefetch" href="/assets/js/4.42df7ce9.js"><link rel="prefetch" href="/assets/js/40.956a7ac0.js"><link rel="prefetch" href="/assets/js/41.cb2601dd.js"><link rel="prefetch" href="/assets/js/42.82715b99.js"><link rel="prefetch" href="/assets/js/43.aee2a16a.js"><link rel="prefetch" href="/assets/js/44.faa3ab83.js"><link rel="prefetch" href="/assets/js/45.ab21f6aa.js"><link rel="prefetch" href="/assets/js/46.e05be02e.js"><link rel="prefetch" href="/assets/js/47.36282390.js"><link rel="prefetch" href="/assets/js/48.b2efd136.js"><link rel="prefetch" href="/assets/js/49.fbea41f0.js"><link rel="prefetch" href="/assets/js/5.c6cf20cb.js"><link rel="prefetch" href="/assets/js/50.ad50bd42.js"><link rel="prefetch" href="/assets/js/51.ea8d8bd6.js"><link rel="prefetch" href="/assets/js/52.b9df09ef.js"><link rel="prefetch" href="/assets/js/53.301bb916.js"><link rel="prefetch" href="/assets/js/54.ba873bec.js"><link rel="prefetch" href="/assets/js/55.c129c01d.js"><link rel="prefetch" href="/assets/js/56.3d17ce6c.js"><link rel="prefetch" href="/assets/js/57.24623ed6.js"><link rel="prefetch" href="/assets/js/58.1df7c9ab.js"><link rel="prefetch" href="/assets/js/59.588c128c.js"><link rel="prefetch" href="/assets/js/6.500251ac.js"><link rel="prefetch" href="/assets/js/60.e396d308.js"><link rel="prefetch" href="/assets/js/61.b19bd1be.js"><link rel="prefetch" href="/assets/js/62.2f932fd6.js"><link rel="prefetch" href="/assets/js/63.0d2fe986.js"><link rel="prefetch" href="/assets/js/64.a57e3ab1.js"><link rel="prefetch" href="/assets/js/65.8b21eec3.js"><link rel="prefetch" href="/assets/js/66.421a9b3e.js"><link rel="prefetch" href="/assets/js/67.86d017d7.js"><link rel="prefetch" href="/assets/js/68.9d73a71c.js"><link rel="prefetch" href="/assets/js/69.40a64bcc.js"><link rel="prefetch" href="/assets/js/7.57ec82ab.js"><link rel="prefetch" href="/assets/js/70.710ff4bf.js"><link rel="prefetch" href="/assets/js/71.2648fe76.js"><link rel="prefetch" href="/assets/js/72.433c4a3c.js"><link rel="prefetch" href="/assets/js/73.3a746cf6.js"><link rel="prefetch" href="/assets/js/74.1c7c35d0.js"><link rel="prefetch" href="/assets/js/75.acfeaa69.js"><link rel="prefetch" href="/assets/js/76.515748bd.js"><link rel="prefetch" href="/assets/js/77.1d939c93.js"><link rel="prefetch" href="/assets/js/78.4506ab33.js"><link rel="prefetch" href="/assets/js/79.4b47c294.js"><link rel="prefetch" href="/assets/js/8.ebb39e11.js"><link rel="prefetch" href="/assets/js/80.a9e39005.js"><link rel="prefetch" href="/assets/js/81.286b2cff.js"><link rel="prefetch" href="/assets/js/82.7e405530.js"><link rel="prefetch" href="/assets/js/83.14b4ef4c.js"><link rel="prefetch" href="/assets/js/84.347158a0.js"><link rel="prefetch" href="/assets/js/85.99eba8cd.js"><link rel="prefetch" href="/assets/js/86.17244fae.js"><link rel="prefetch" href="/assets/js/87.26e532b6.js"><link rel="prefetch" href="/assets/js/88.edbf421e.js"><link rel="prefetch" href="/assets/js/89.7ae3aabc.js"><link rel="prefetch" href="/assets/js/9.0533239d.js"><link rel="prefetch" href="/assets/js/90.3f040f14.js"><link rel="prefetch" href="/assets/js/91.24e5d990.js"><link rel="prefetch" href="/assets/js/92.b1376b57.js"><link rel="prefetch" href="/assets/js/93.92237822.js"><link rel="prefetch" href="/assets/js/94.12d44698.js"><link rel="prefetch" href="/assets/js/95.f4abc18c.js"><link rel="prefetch" href="/assets/js/96.ba86ad30.js"><link rel="prefetch" href="/assets/js/97.0a41e6f4.js"><link rel="prefetch" href="/assets/js/98.a2e7eb32.js"><link rel="prefetch" href="/assets/js/99.ddc53939.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e4d8b86b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/logo.png" alt="Front-End-Basics" class="logo"> <span class="site-name can-hide">Front-End-Basics</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/article/" class="nav-link">
  捡贝壳
</a></div> <a href="https://github.com/qiqihaobenben/Front-End-Basics" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/article/" class="nav-link">
  捡贝壳
</a></div> <a href="https://github.com/qiqihaobenben/Front-End-Basics" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>基础篇</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>应用篇</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/javascript/utility/fp.html" aria-current="page" class="active sidebar-link">函数式编程</a></li><li><a href="/javascript/utility/cache.html" class="sidebar-link">三种本地存储方式和一些扩展</a></li><li><a href="/javascript/utility/module.html" class="sidebar-link">JavaScript 的模块</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>数据结构和算法</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>TypeScript</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="函数式编程"><a href="#函数式编程" class="header-anchor">#</a> 函数式编程</h2> <h3 id="什么是函数式编程-为何它重要"><a href="#什么是函数式编程-为何它重要" class="header-anchor">#</a> 什么是函数式编程？为何它重要？</h3> <h4 id="数学中的函数"><a href="#数学中的函数" class="header-anchor">#</a> 数学中的函数</h4> <div class="language- extra-class"><pre class="language-text"><code>f(x) = y
// 一个函数f，以x为参数，并返回输出y
</code></pre></div><p>关键点：</p> <ul><li>函数必须总是接受一个参数</li> <li>函数必须总是返回一个值</li> <li>函数应该依据接收到的参数（例如x）而不是外部环境运行</li> <li>对于一个给定的x，只会输出唯一的一个y</li></ul> <p>函数式编程技术主要基于数学函数和它的思想，所以要理解函数式编程，先了解数学函数是有必要的。</p> <h3 id="函数式编程的定义"><a href="#函数式编程的定义" class="header-anchor">#</a> 函数式编程的定义</h3> <p><strong>函数</strong>是一段可以通过其名称被调用的代码。它可以接受参数，并返回值。</p> <p>与面向对象编程（Object-oriented programming）和过程式编程（Procedural programming）一样，函数式编程（Functional programming）也是一种编程范式。我们能够以此创建仅依赖输入就可以完成自身逻辑的函数。这保证了当函数被多次调用时仍然返回相同的结果（引用透明性）。函数不会改变任何外部环境的变量，这将产生可缓存的，可测试的代码库。</p> <h3 id="函数式编程具有以下特征"><a href="#函数式编程具有以下特征" class="header-anchor">#</a> 函数式编程具有以下特征</h3> <h4 id="_1、引用透明性"><a href="#_1、引用透明性" class="header-anchor">#</a> 1、引用透明性</h4> <p>所有的函数对于相同的输入都将返回相同的值，函数的这一属性被称为<strong>引用透明性（Referential Transparency）</strong></p> <div class="language- extra-class"><pre class="language-text"><code>// 引用透明的例子，函数identity无论输入什么，都会原封不动的返回
var identity = (i) =&gt; {return i}
</code></pre></div><h5 id="替换模型"><a href="#替换模型" class="header-anchor">#</a> 替换模型</h5> <p>把一个引用透明的函数用于其他函数调用之间。</p> <p><code>sum(4,5) + identity(1)</code></p> <p>根据引用透明的定义，我们可以把上面的语句换成：</p> <p><code>sum(4,5) + 1</code></p> <p>该过程被称为替换模型（Substitution Model）,因为函数的逻辑不依赖其他全局变量，你可以直接替换函数的结果，这与它的值是一样的。所以，这使得<strong>并发代码</strong>和<strong>缓存</strong>成为可能。</p> <p><strong>并发代码：</strong> 并发运行的时候，如果依赖了全局数据，要保证数据一致，必须同步，而且必要时需要锁机制。遵循引用透明的函数只依赖参数的输入，所以可以自由的运行。</p> <p><strong>缓存：</strong> 由于函数会为给定的输入返回相同的值，实际上我们就能缓存它了。比如实现一个计算给定数值的阶乘的函数，我们就可以把每次阶乘的结果缓存下来，下一次直接用，就不用计算了。比如第一次输入5，结果是120，第二次输入5，我们知道结果必然是120，所以就可以返回已缓存的值，而不必再计算一次。</p> <h4 id="_2、声明式和抽象"><a href="#_2、声明式和抽象" class="header-anchor">#</a> 2、声明式和抽象</h4> <p>函数式编程主张声明式编程和编写抽象的代码。</p> <h5 id="比较命令式和声明式"><a href="#比较命令式和声明式" class="header-anchor">#</a> 比较命令式和声明式</h5> <div class="language- extra-class"><pre class="language-text"><code>// 有一个数组，要遍历它并把它打印到控制台

/*命令式*/
var array = [1,2,3]
for(var i = 0; i &lt; array.length; i++)
console(array[i]) // 打印 1,2,3

// 命令式编程中，我们精确的告诉程序应该“如何”做：获取数组的长度，通过数组的长度循环数组，在每一次循环中用索引获取每一个数组元素，然后打印出来。
// 但是我们的任务只是打印出数组的元素。并不是要告诉编译器要如何实现一个遍历。



/*声明式*/
var array = [1,2,3]
array.forEach((element) =&gt; console.log(element)) // 打印 1,2,3

// 我们使用了一个处理“如何”做的抽象函数，然后我们就能只关心做“什么”了
</code></pre></div><h5 id="函数式编程主张以抽象的方式创建函数-例如上文的foreach-这些函数能够在代码的其他部分被重用。"><a href="#函数式编程主张以抽象的方式创建函数-例如上文的foreach-这些函数能够在代码的其他部分被重用。" class="header-anchor">#</a> 函数式编程主张以抽象的方式创建函数，例如上文的forEach，这些函数能够在代码的其他部分被重用。</h5> <h4 id="_3、纯函数"><a href="#_3、纯函数" class="header-anchor">#</a> 3、纯函数</h4> <p>大多数函数式编程的好处来自于编写纯函数，<strong>纯函数</strong>是对给定的输入返回相同的输出的函数，并且纯函数不应依赖任何外部变量，也不应改变任何外部变量。</p> <h5 id="纯函数的好处"><a href="#纯函数的好处" class="header-anchor">#</a> 纯函数的好处</h5> <ol><li>纯函数产生容易测试的代码</li> <li>纯函数容易写出合理的代码</li> <li>纯函数容易写出并发代码
纯函数总是允许我们并发的执行代码。因为纯函数不会改变它的环境，这意味着我们根本不需要担心同步问题。</li> <li>纯函数的输出结果可缓存
既然纯函数总是为给定的输入返回相同的输出，那么我们就能够缓存函数的输出。</li></ol> <h2 id="高阶函数"><a href="#高阶函数" class="header-anchor">#</a> 高阶函数</h2> <h3 id="数据和数据类型"><a href="#数据和数据类型" class="header-anchor">#</a> 数据和数据类型</h3> <p>程序作用于数据，数据对于程序的执行很重要。每种编程语言都有数据类型。这些数据类型能够存储数据并允许程序作用其中。</p> <h3 id="javascript中函数是一等公民-first-class-citizens"><a href="#javascript中函数是一等公民-first-class-citizens" class="header-anchor">#</a> JavaScript中函数是一等公民(First Class Citizens)</h3> <p>**当一门语言允许函数作为任何其他数据类型使用时，函数被称为一等公民。**也就是说函数可被赋值给变量，作为参数传递，也可被其他函数返回。</p> <p>函数作为JavaScript的一种数据类型，由于函数是类似String的数据类型，所以我们能把函数存入一个变量，能够作为函数的参数进行传递。所以JavaScript中函数是一等公民。</p> <h3 id="高阶函数的定义"><a href="#高阶函数的定义" class="header-anchor">#</a> 高阶函数的定义</h3> <p>接受另一个函数作为其参数的函数称为高阶函数(Higher-Order-Function)，或者说高阶函数是接受函数作为参数并且/或者返回函数作为输出的函数。</p> <h3 id="抽象和高阶函数"><a href="#抽象和高阶函数" class="header-anchor">#</a> 抽象和高阶函数</h3> <p>一般而言，高阶函数通常用于抽象通用的问题，换句话说，高阶函数就是定义抽象。</p> <p><strong>抽象</strong> ： 在软件工程和计算机科学中，抽象是一种管理计算机系统复杂性的技术。 通过建立一个人与系统进行交互的复杂程度，把更复杂的细节抑制在当前水平之下。简言之，抽象让我们专注于预定的目标而无须关心底层的系统概念。</p> <blockquote><p>例如：你在编写一个涉及数值操作的代码，你不会对底层硬件的数字表现方式到底是16位还是32位整数有很深的了解，包括这些细节在哪里屏蔽。因为它们被抽象出来了，只留下了简单的数字给我们使用。</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>// 用forEach抽象出遍历数组的操作
const forEach = (array,fn) =&gt; {
  let i;
  for(i=0;i&lt;array.length;i++) {
    fn(array[i])
  }
}

// 用户不需要理解forEach是如何实现遍历的，如此问题就被抽象出来了。
//例如，想要打印出数组的每一项
let array = [1,2,3]
forEach(array,(data) =&gt; console.log(data))
</code></pre></div><h3 id="闭包和高阶函数"><a href="#闭包和高阶函数" class="header-anchor">#</a> 闭包和高阶函数</h3> <p>什么是闭包？简言之，**闭包就是一个内部函数。**什么是内部函数？就是在另一个函数内部的函数。</p> <p>闭包的强大之处在于它对作用域链（或作用域层级）的访问。从技术上讲，闭包有3个可访问的作用域。</p> <p>(1) 在它自身声明之内声明的变量</p> <p>(2) 对全局变量的访问</p> <p>(3) 对外部函数变量的访问（关键点）</p> <p><strong>实例一</strong>：假设你再遍历一个来自服务器的数组，并发现数据错了。你想调试一下，看看数组里面究竟包含了什么。不要用命令式的方法，要用函数式的方法来实现。这里就需要一个 tap 函数。</p> <div class="language- extra-class"><pre class="language-text"><code>const tap = (value) =&gt; {
  return (fn) =&gt; {
    typeof fn === 'function' &amp;&amp; fn(value)
    console.log(value)
  }
}

// 没有调试之前
forEach(array, data =&gt; {
  console.log(data + data)
})

// 在 forEach 中使用 tap 调试
forEach(array, data =&gt; {
  tap(data)(() =&gt; {
    console.log(data + data)
  })
})
</code></pre></div><p>完成一个简单的reduce函数</p> <div class="language- extra-class"><pre class="language-text"><code>const reduce = (array,fn,initialValue) =&gt; {
  let accumulator;
  if(initialValue != undefined)
    accumulator = initialValue
  else
    accumulator = array[0]

  if(initialValue === undefined)
    for(let i = 1; i &lt; array.length; i++)
      accumulator = fn(accumulator, array[i])
  else
    for(let value of array)
      accumulator = fn(accumulator,value)
  return accumulator
}

console.log(reduce([1,2,3], (accumulator,value) =&gt; accumulator + value))
// 打印出6
</code></pre></div><h2 id="柯里化与偏应用"><a href="#柯里化与偏应用" class="header-anchor">#</a> 柯里化与偏应用</h2> <h3 id="一些概念"><a href="#一些概念" class="header-anchor">#</a> 一些概念</h3> <h4 id="一元函数"><a href="#一元函数" class="header-anchor">#</a> 一元函数</h4> <p>只接受一个参数的函数称为一元(unary)函数。</p> <h4 id="二元函数"><a href="#二元函数" class="header-anchor">#</a> 二元函数</h4> <p>只接受两个参数的函数称为二元(binary)函数。</p> <h4 id="变参函数"><a href="#变参函数" class="header-anchor">#</a> 变参函数</h4> <p>变参函数是接受可变数量的函数。</p> <h3 id="柯里化"><a href="#柯里化" class="header-anchor">#</a> 柯里化</h3> <p>柯里化是把一个多参数函数转换为一个嵌套的一元函数的过程。</p> <p>例如</p> <div class="language- extra-class"><pre class="language-text"><code>// 一个多参数函数
const add = (x,y) =&gt; x + y;
add(2,3)

// 一个嵌套的一元函数
const addCurried = x =&gt; y =&gt; x + y;
addCurried(2)(3)

// 然后我们写一个高阶函数，把 add 转换成 addCurried 的形式。
const curry = (binaryFn) =&gt; {
  return function (firstArg) {
    return function (secondArg) {
      return binaryFn(firstArg,secondArg)
    }
  }
}
let autoCurriedAdd = carry(add)
autoCurriedAdd(2)(3)
</code></pre></div><p>上面只是简单实现了一个二元函数的柯里化，下面我们要实现一个更多参数的函数的柯里化。</p> <div class="language- extra-class"><pre class="language-text"><code>const curry = (fn) =&gt; {
  if (typeof fn !== 'function') {
    throw Error('No function provided')
  }
  return function curriedFn (...args) {
    // 判断当前接受的参数是不是小于进行柯里化的函数的参数个数
    if(args.length &lt; fn.length) {
      // 如果小于的话就返回一个函数再去接收剩下的参数
      return function (...argsOther) {
        return curriedFn.apply(null, args.concat(argsOther))
      }
    }else {
      return fn.apply(null,args)
    }
  }
}

 const multiply = (x,y,z) =&gt; x * y * z;
 console.log(curry(multiply)(2)(3)(4))
</code></pre></div><p>柯里化的应用实例：从数组中找出含有数字的元素</p> <div class="language- extra-class"><pre class="language-text"><code>let match = curry(function (expr,str) {
  return str.match(expr)
})
let hasNumber = match(/[0-9]+/)

let initFilter = curry(function (fn,array) {
  return array.filter(fn)
})

let findNumberInArray = initFilter(hasNumber)
console.log(findNumberInArray(['aaa', 'bb2', '33c', 'ddd', ]))
// 打印 [ 'bb2', '33c' ]
</code></pre></div><h3 id="偏应用"><a href="#偏应用" class="header-anchor">#</a> 偏应用</h3> <p>我们上面设计的柯里化函数总是在最后接受一个数组，这使得它能接受的参数列表只能是从最左到最右。</p> <p>但是有时候，我们不能按照从左到右的这样严格传入参数，或者只是想部分地应用函数参数。这里我们就需要用到偏应用这个概念，它允许开发者部分地应用函数参数。</p> <div class="language- extra-class"><pre class="language-text"><code>const partial = function (fn, ...partialArgs) {
  return function (...fullArguments) {
    let args = partialArgs
    let arg = 0;
    for(let i = 0; i &lt; args.length &amp;&amp; arg &lt; fullArguments.length; i++) {
      if(args[i] === undefined) {
        args[i] = fullArguments[arg++]
      }
    }
    return fn.apply(null,args)
  }
}
</code></pre></div><p>偏应用的示例：</p> <div class="language- extra-class"><pre class="language-text"><code>// 打印某个格式化的JSON
let prettyPrintJson = partial(JSON.stringify,undefined,null,2)
console.log(prettyPrintJson({name:'fangxu',gender:'male'}))

// 打印出
{
  &quot;name&quot;: &quot;fangxu&quot;,
  &quot;gender&quot;: &quot;male&quot;
}
</code></pre></div><h2 id="组合与管道"><a href="#组合与管道" class="header-anchor">#</a> 组合与管道</h2> <h3 id="unix的理念"><a href="#unix的理念" class="header-anchor">#</a> Unix的理念</h3> <ol><li>每个程序只做好一件事情，为了完成一项新的任务，重新构建要好于在复杂的旧程序中添加新“属性”。</li> <li>每个程序的输出应该是另一个尚未可知的程序的输入。</li> <li>每一个基础函数都需要接受一个参数并返回数据。</li></ol> <h3 id="组合-compose"><a href="#组合-compose" class="header-anchor">#</a> 组合(compose)</h3> <div class="language- extra-class"><pre class="language-text"><code>const compose = (...fns) =&gt; {
  return (value) =&gt; reduce(fns.reverse(),(acc,fn) =&gt; fn(acc), value)
}
</code></pre></div><p>compose 组合的函数，是按照传入的顺序从右到左调用的。所以传入的 fns 要先 reverse 一下，然后我们用到了reduce ，reduce 的累加器初始值是 value ，然后会调用 <code>(acc,fn) =&gt; fn(acc)</code>, 依次从 fns 数组中取出 fn ，将累加器的当前值传入 fn ，即把上一个函数的返回值传递到下一个函数的参数中。</p> <p>组合的实例：</p> <div class="language- extra-class"><pre class="language-text"><code>let splitIntoSpace = (str) =&gt; str.split(' ')
let count = (array) =&gt; array.length
const countWords = composeN(count, splitIntoSpace)
console.log(countWords('make smaller or less in amount'))
// 打印 6
</code></pre></div><h3 id="管道-序列"><a href="#管道-序列" class="header-anchor">#</a> 管道/序列</h3> <p>compose 函数的数据流是从右往左的，最右侧的先执行。当然，我们还可以让最左侧的函数先执行，最右侧的函数最后执行。这种从左至右处理数据流的过程称为管道（pipeline）或序列(sequence)。</p> <div class="language- extra-class"><pre class="language-text"><code>// 跟compose的区别，只是没有调用fns.reverse()
const pipe = (...fns) =&gt; (value) =&gt; reduce(fns,(acc,fn) =&gt; fn(acc),value)
</code></pre></div><h2 id="函子"><a href="#函子" class="header-anchor">#</a> 函子</h2> <h3 id="什么是函子-functor"><a href="#什么是函子-functor" class="header-anchor">#</a> 什么是函子(Functor)？</h3> <p><strong>定义</strong>：函子是一个普通对象（在其它语言中，可能是一个类），它实现了map函数，在遍历每个对象值的时候生成一个新对象。</p> <h4 id="实现一个函子"><a href="#实现一个函子" class="header-anchor">#</a> 实现一个函子</h4> <p>1、简言之，函子是一个持有值的容器。而且函子是一个普通对象。我们就可以创建一个容器（也就是对象），让它能够持有任何传给它的值。</p> <div class="language- extra-class"><pre class="language-text"><code>const Container = function (value) {
  this.value = value
}

let testValue = new Container(1)
// =&gt; Container {value:1}
</code></pre></div><p>我们给 Container 增加一个静态方法，它可以为我们在创建新的 Containers 时省略 new 关键字。</p> <div class="language- extra-class"><pre class="language-text"><code>Container.of = function (value) {
  return new Container(value)
}

// 现在我们就可以这样来创建
Container.of(1)
// =&gt; Container {value:1}
</code></pre></div><p>2、函子需要实现 map 方法，具体的实现是，map 函数从 Container 中取出值，传入的函数把取出的值作为参数调用，并将结果放回 Container。</p> <blockquote><p>为什么需要 map 函数，我们上面实现的 Container 仅仅是持有了传给它的值。但是持有值的行为几乎没有任何应用场景，而 map 函数发挥的作用就是，允许我们使用当前 Container 持有的值调用任何函数。</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>Container.prototype.map = function (fn) {
  return Container.of(fn(this.value))
}

// 然后我们实现一个数字的 double 操作
let double = (x) =&gt; x + x;
Container.of(3).map(double)
// =&gt; Container {value: 6}
</code></pre></div><p>3、map返回了一传入函数的执行结果为值的 Container 实例，所以我们可以链式操作。</p> <div class="language- extra-class"><pre class="language-text"><code>Container.of(3).map(double).map(double).map(double)
// =&gt; Container {value: 24}
</code></pre></div><p><strong>通过以上的实现，我们可以发现，函子就是一个实现了map契约的对象。函子是一个寻求契约的概念，该契约很简单，就是实现 map 。根据实现 map 函数的方式不同，会产生不同类型的函子，如 MayBe 、 Either</strong></p> <p>函子可以用来做什么？之前我们用tap函数来函数式的解决代码报错的调试问题，如何更加函数式的处理代码中的问题，那就需要用到下面我们说的MayBe函子</p> <h3 id="maybe-函子"><a href="#maybe-函子" class="header-anchor">#</a> MayBe 函子</h3> <p>让我们先写一个upperCase函数来假设一种场景</p> <div class="language- extra-class"><pre class="language-text"><code>let value = 'string';
function upperCase(value) {
  // 为了避免报错，我们得写这么一个判断
  if(value != null || value != undefined)
    return value.toUpperCase()
}
upperCase(value)
// =&gt; STRING
</code></pre></div><p>如上面所示，我们代码中经常需要判断一些<code>null</code>和<code>undefined</code>的情况。下面我们来看一下MayBe函子的实现。</p> <div class="language- extra-class"><pre class="language-text"><code>// MayBe 跟上面的 Container 很相似
export const MayBe = function (value) {
  this.value = value
}
MayBe.of = function (value) {
  return new MayBe(value)
}
// 多了一个isNothing
MayBe.prototype.isNoting = function () {
  return this.value === null || this.value === undefined;
}
// 函子必定有 map,但是 map 的实现方式可能不同
MayBe.prototype.map = function(fn) {
  return this.isNoting()?MayBe.of(null):MayBe.of(fn(this.value))
}

// MayBe应用
let value = 'string';
MayBe.of(value).map(upperCase)
// =&gt; MayBe { value: 'STRING' }
let nullValue = null
MayBe.of(nullValue).map(upperCase)
// 不会报错 MayBe { value: null }
</code></pre></div><h3 id="either-函子"><a href="#either-函子" class="header-anchor">#</a> Either 函子</h3> <div class="language- extra-class"><pre class="language-text"><code>MayBe.of(&quot;tony&quot;)
  .map(() =&gt; undefined)
  .map((x)f =&gt; &quot;Mr. &quot; + x)
</code></pre></div><p>上面的代码结果是 <code>MyaBe {value: null}</code>,这只是一个简单的例子，我们可以想一下，如果代码比较复杂，我们是不知道到底是哪一个分支在检查 undefined 和 null 值时执行失败了。这时候我们就需要 Either 函子了，它能解决分支拓展问题。</p> <div class="language- extra-class"><pre class="language-text"><code>const Nothing = function (value) {
  this.value = value;
}
Nothing.of = function (value) {
  return new Nothing(value)
}
Nothing.prototype.map = function (fn) {
  return this;
}
const Some = function (value) {
  this.value = value;
}
Some.of = function (value) {
  return new Some(value)
}
Some.prototype.map = function (fn) {
  return Some.of(fn(this.value));
}

const Either = {
  Some,
  Nothing
}

</code></pre></div><h3 id="pointed-函子"><a href="#pointed-函子" class="header-anchor">#</a> Pointed 函子</h3> <p>函子只是一个实现了 map 契约的接口。Pointed 函子也是一个函子的子集，它具有实现了 of 契约的接口。 我们在 MayBe 和 Either 中也实现了 of 方法，用来在创建 Container 时不使用 new 关键字。所以 MayBe 和 Either 都可称为 Pointed 函子。</p> <blockquote><p>ES6 增加了 Array.of， 这使得数组成为了一个 Pointed 函子。</p></blockquote> <h3 id="monad-函子"><a href="#monad-函子" class="header-anchor">#</a> Monad 函子</h3> <p>MayBe 函子很可能会出现嵌套，如果出现嵌套后，我们想要继续操作真正的value是有困难的。必须深入到 MayBe 内部进行操作。</p> <div class="language- extra-class"><pre class="language-text"><code>let joinExample = MayBe.of(MayBe.of(5));
// =&gt; MayBe { value: MayBe { value: 5 } }

// 这个时候我们想让5加上4，需要深入 MayBe 函子内部
joinExample.map((insideMayBe) =&gt; {
  return insideMayBe.map((value) =&gt; value + 4)
})
// =&gt; MayBe { value: MayBe { value: 9 } }
</code></pre></div><p>我们这时就可以实现一个 join 方法来解决这个问题。</p> <div class="language- extra-class"><pre class="language-text"><code>// 如果通过 isNothing 的检查，就返回自身的 value
MayBe.prototype.join = function () {
  return this.isNoting()? MayBe.of(null) : this.value
}
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>let joinExample2 = MayBe.of(MayBe.of(5));
// =&gt; MayBe { value: MayBe { value: 5 } }

// 这个时候我们想让5加上4就很简单了。
joinExample2.join().map((value) =&gt; value + 4)
// =&gt; MayBe { value: 9 }
</code></pre></div><p>再延伸一下，我们扩展一个 chain 方法。</p> <div class="language- extra-class"><pre class="language-text"><code>MayBe.prototype.chain = function (fn) {
  return this.map(fn).join()
}
</code></pre></div><p>调用 chain 后就能把嵌套的 MayBe 展开了。</p> <div class="language- extra-class"><pre class="language-text"><code>let joinExample3 = MayBe.of(MayBe.of(5));
// =&gt; MayBe { value: MayBe { value: 5 } }


joinExample3.chain((insideMayBe) =&gt; {
  return insideMayBe.map((value) =&gt; value + 4)
})
// =&gt; MayBe { value: 9 }
</code></pre></div><p><strong>Monad</strong> 其实就是一个含有 chain 方法的函子。只有of 和 map 的 MayBe 是一个函子，含有 chain 的函子是一个 Monad。</p> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <h3 id="javascript是函数式编程语言吗"><a href="#javascript是函数式编程语言吗" class="header-anchor">#</a> JavaScript是函数式编程语言吗？</h3> <p>函数式编程主张函数必须接受至少一个参数并返回一个值，但是JavaScript允许我们创建一个不接受参数并且实际上什么也不返回的函数。所以JavaScript不是一种纯函数语言，更像是一种多范式的语言，不过它非常适合函数式编程范式。</p> <p>JavaScript是一门多范型语言，或者也称为混合范型语言。JavaScript 的简单来自于此，复杂也来自于此；生存能力来自于此，抨击诟病也来自于此。</p> <h2 id="补充"><a href="#补充" class="header-anchor">#</a> 补充</h2> <h3 id="_1、纯函数是数学函数"><a href="#_1、纯函数是数学函数" class="header-anchor">#</a> 1、纯函数是数学函数</h3> <div class="language- extra-class"><pre class="language-text"><code>function generateGetNumber() {
  let numberKeeper = {}
  return function (number) {
    return numberKeeper.hasOwnProperty(number) ?
    number :
    numberKeeper[number] = number + number
  }
}
const getNumber = generateGetNumber()
getNumber(1)
getNumber(2)
……
getNumber(9)
getNumber(10)

// 此时numberKeeper为：
{
  1: 2
  2: 4
  3: 6
  4: 8
  5: 10
  6: 12
  7: 14
  8: 16
  9: 18
  10: 20
}
</code></pre></div><p>现在我们规定，getNumber只接受1-10范围的参数，那么返回值肯定是 numberKeeper 中的某一个 value 。据此我们分析一下 getNumber ,该函数接受一个输入并为给定的范围（此处范围是10）映射输出。输入具有强制的、相应的输出，并且也不存在映射两个输出的输入。</p> <p>下面我来再看一下数学函数的定义（维基百科）</p> <blockquote><p>在数学中，函数是一种输入集合和可允许的输出集合之间的关系，具有如下属性：每个输入都精确地关联一个输出。函数的输入称为参数，输出称为值。对于一个给定的函数，所有被允许的输入集合称为该函数的定义域，而被允许的输出集合称为值域。</p></blockquote> <p>根据我们对于 getNumber 的分析，对照数学函数的定义，会发现完全一致。我们上面的getNumber函数的定义域是1-10，值域是2,4,6,……18,20</p> <h3 id="_2、实例"><a href="#_2、实例" class="header-anchor">#</a> 2、实例</h3> <p>文中所有的概念对应的实例可以在 <a href="https://github.com/qiqihaobenben/learning-functional" target="_blank" rel="noopener noreferrer">https://github.com/qiqihaobenben/learning-functional<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 获取，可以打开对应的注释来实际执行一下。</p> <h3 id="_3、荐书"><a href="#_3、荐书" class="header-anchor">#</a> 3、荐书</h3> <p><a href="https://book.douban.com/subject/30180100/" target="_blank" rel="noopener noreferrer">《JavaScript ES6 函数式编程入门经典》<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>,强烈建议想入门函数式编程的同学看一下，书有点老，可以略过工具介绍之类的，关键看其内在的思想，最重要的是，这本书很薄，差不多跟一本漫画书类似。</p> <h3 id="_4、推荐文章-非引用文章"><a href="#_4、推荐文章-非引用文章" class="header-anchor">#</a> 4、推荐文章（非引用文章）</h3> <ol><li><a href="https://www.h5jun.com/post/js-functional-1.html" target="_blank" rel="noopener noreferrer">漫谈 JS 函数式编程（一）<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.h5jun.com/post/parseInt-to-functional.html" target="_blank" rel="noopener noreferrer">从一道坑人的面试题说函数式编程<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html" target="_blank" rel="noopener noreferrer">函数式编程入门教程<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://yanhaijing.com/javascript/2018/03/01/functional-programming-practice/" target="_blank" rel="noopener noreferrer">函数式编程的一点实战<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ol></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/qiqihaobenben/Front-End-Basics/edit/master/docs/javascript/utility/fp.md" target="_blank" rel="noopener noreferrer">在 GitHub 上编辑此页</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">10/18/2021, 5:27:33 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/javascript/utility/data-interaction/cross-origin.html" class="prev">
        前端请求跨域
      </a></span> <span class="next"><a href="/javascript/utility/cache.html">
        三种本地存储方式和一些扩展
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.3f9992d7.js" defer></script><script src="/assets/js/2.b9bee1c3.js" defer></script><script src="/assets/js/147.486b066a.js" defer></script>
  </body>
</html>
